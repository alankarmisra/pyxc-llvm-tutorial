# Experimental pcompiler (written in pyxc)
# Compiles a tiny expression language to stack-machine text.
# Grammar:
#   expr   := term ((+|-) term)*
#   term   := factor ((*|/) factor)*
#   factor := number | '(' expr ')'

struct Parser:
    src: ptr[i8]
    pos: i32
    out: ptr[void]
    ok: i32

extern def parse_expr(p: ptr[Parser]) -> void
extern def parse_term(p: ptr[Parser]) -> void
extern def parse_factor(p: ptr[Parser]) -> void


def cur(p: ptr[Parser]) -> i8:
    s: ptr[i8] = p[0].src
    return s[p[0].pos]


def advance(p: ptr[Parser]) -> void:
    p[0].pos = p[0].pos + 1
    return


def is_space(c: i8) -> i32:
    if c == 32:
        return 1
    if c == 9:
        return 1
    if c == 10:
        return 1
    if c == 13:
        return 1
    return 0


def skip_ws(p: ptr[Parser]) -> void:
    while is_space(cur(p)) != 0:
        advance(p)
    return


def emit_char(out: ptr[void], c: i8) -> void:
    tmp: array[i8, 2]
    tmp[0] = c
    tmp[1] = 0
    fputs(addr(tmp[0]), out)
    return


def emit_push_digits(p: ptr[Parser], start: i32, end_: i32) -> void:
    i: i32 = 0
    s: ptr[i8] = p[0].src
    fputs("PUSH ", p[0].out)
    i = start
    while i < end_:
        emit_char(p[0].out, s[i])
        i = i + 1
    fputs("\n", p[0].out)
    return


def parse_expr(p: ptr[Parser]) -> void:
    parse_term(p)
    skip_ws(p)

    while p[0].ok != 0:
        c: i8 = cur(p)
        if c == 43:
            advance(p)
            parse_term(p)
            fputs("ADD\n", p[0].out)
        elif c == 45:
            advance(p)
            parse_term(p)
            fputs("SUB\n", p[0].out)
        else:
            return

        skip_ws(p)

    return


def parse_term(p: ptr[Parser]) -> void:
    parse_factor(p)
    skip_ws(p)

    while p[0].ok != 0:
        c: i8 = cur(p)
        if c == 42:
            advance(p)
            parse_factor(p)
            fputs("MUL\n", p[0].out)
        elif c == 47:
            advance(p)
            parse_factor(p)
            fputs("DIV\n", p[0].out)
        else:
            return

        skip_ws(p)

    return


def parse_factor(p: ptr[Parser]) -> void:
    skip_ws(p)

    c: i8 = cur(p)

    if c == 40:
        advance(p)
        parse_expr(p)
        skip_ws(p)
        if cur(p) != 41:
            p[0].ok = 0
            printf("parse error: expected ')' at byte %d\n", p[0].pos)
            return
        advance(p)
        return

    if isdigit(c) != 0:
        start: i32 = p[0].pos
        while isdigit(cur(p)) != 0:
            advance(p)
        emit_push_digits(p, start, p[0].pos)
        return

    p[0].ok = 0
    printf("parse error: unexpected token at byte %d\n", p[0].pos)
    return


def compile_expr_to_file(src: ptr[i8], out_path: ptr[i8]) -> i32:
    out: ptr[void] = fopen(out_path, "w")

    p: ptr[Parser] = malloc[Parser](1)
    p[0].src = src
    p[0].pos = 0
    p[0].out = out
    p[0].ok = 1

    parse_expr(p)
    skip_ws(p)

    if p[0].ok != 0:
        if cur(p) != 0:
            p[0].ok = 0
            printf("parse error: trailing input at byte %d\n", p[0].pos)

    ok: i32 = p[0].ok
    fclose(out)
    free(p)

    if ok != 0:
        return 0
    return 2


def main() -> i32:
    # Demo input for the prototype compiler.
    src: ptr[i8] = "12 + 3*(4+5) - 7"

    rc: i32 = compile_expr_to_file(src, "pcompiler.out")
    if rc == 0:
        printf("ok: wrote pcompiler.out\n")
    else:
        printf("compile failed: rc=%d\n", rc)

    return rc


main()
