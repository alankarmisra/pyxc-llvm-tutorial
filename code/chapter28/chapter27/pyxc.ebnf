(* Pyxc Grammar (Chapter 15 draft: explicit types + pointer types) *)

(* ---------- Lexical ---------- *)

letter         = "A".."Z" | "a".."z" | "_" ;
digit          = "0".."9" ;
identifier     = letter , { letter | digit } ;
string_literal = "\"" , { ? any char except " or newline; escapes allowed ? } , "\"" ;
number         = digit , { digit } , [ "." , { digit } ]
               | "." , digit , { digit } ;

newline        = "<EOL>" ;
indent         = "<INDENT>" ;
dedent         = "<DEDENT>" ;
eof            = "<EOF>" ;

(* Produced by lexer indentation logic; parser consumes these as tokens. *)

(* ---------- Program ---------- *)

program         = { top_item } , eof ;

top_item        = newline
                | type_alias_decl
                | struct_decl
                | function_def
                | extern_decl
                | statement ;

(* ---------- Types ---------- *)

type_alias_decl = "type" , identifier , "=" , type_expr ;
struct_decl     = "struct" , identifier , ":" , newline , indent ,
                  struct_field , { newline , struct_field } , [ newline ] ,
                  dedent ;
struct_field    = identifier , ":" , type_expr ;

type_expr       = pointer_type
                | array_type
                | base_type ;

pointer_type    = "ptr" , "[" , type_expr , "]" ;
array_type      = "array" , "[" , type_expr , "," , array_size , "]" ;
array_size      = number ;

base_type       = builtin_type
                | identifier ;

builtin_type    = "void"
                | "i8" | "i16" | "i32" | "i64"
                | "u8" | "u16" | "u32" | "u64"
                | "f32" | "f64" ;

(* ---------- Functions ---------- *)

function_def    = "def" , prototype , ":" , suite ;
extern_decl     = "extern" , "def" , prototype ;

prototype       = identifier , "(" , [ param_list ] , ")" , "->" , type_expr ;
(* executable entrypoint supports:
   def main() -> i32
   def main(argc: i32, argv: ptr[ptr[i8]]) -> i32
   (enforced in codegen) *)
param_list      = param , { "," , param } ;
param           = identifier , ":" , type_expr ;

(* ---------- Statements ---------- *)

statement       = if_stmt
                | match_stmt
                | for_stmt
                | while_stmt
                | do_while_stmt
                | break_stmt
                | continue_stmt
                | free_stmt
                | print_stmt
                | return_stmt
                | const_decl_stmt
                | typed_assign_stmt
                | assign_stmt
                | expr_stmt ;

const_decl_stmt = "const" , identifier , ":" , type_expr , "=" , expression ;
typed_assign_stmt = identifier , ":" , type_expr , [ "=" , expression ] ;
assign_stmt     = lvalue , "=" , expression ;
lvalue          = identifier
                | index_expr
                | member_expr ;

expr_stmt       = expression ;

return_stmt     = "return" , [ expression ] ;

print_stmt      = "print" , "(" , [ arg_list ] , ")" ;
free_stmt       = "free" , "(" , expression , ")" ;

if_stmt         = "if" , expression , ":" , suite ,
                  [ "elif" , expression , ":" , suite ] ,
                  [ "else" , ":" , suite ] ;
match_stmt      = "match" , expression , ":" , newline , indent ,
                  case_clause , { newline , case_clause } , [ newline ] ,
                  dedent ;
case_clause     = "case" , ( "_" | expression ) , ":" , suite ;

for_stmt        = "for" , identifier , "in" , "range" , "(" ,
                  expression , "," , expression ,
                  [ "," , expression ] ,
                  ")" , ":" , suite ;

while_stmt      = "while" , expression , ":" , suite ;
do_while_stmt   = "do" , ":" , suite , "while" , expression ;
break_stmt      = "break" ;
continue_stmt   = "continue" ;

(* Python-style suite: either one inline statement or an indented block. *)
suite           = inline_suite
                | block_suite ;

inline_suite    = statement ;
block_suite     = newline , indent , statement_list , dedent ;
statement_list  = statement , { newline , statement } , [ newline ] ;

(* ---------- Expressions ---------- *)

expression      = unary_expr , { binary_op , unary_expr } ;

unary_expr      = [ unary_op ] , postfix_expr ;
unary_op        = "+" | "-" | "!" | "~" ;

postfix_expr    = primary , { call_suffix | index_suffix | member_suffix } ;
call_suffix     = "(" , [ arg_list ] , ")" ;
index_suffix    = "[" , expression , "]" ;
member_suffix   = "." , identifier ;
index_expr      = postfix_expr , index_suffix ;
member_expr     = postfix_expr , member_suffix ;

primary         = number
                | string_literal
                | identifier
                | malloc_expr
                | addr_expr
                | paren_expr
                | var_expr ;

malloc_expr     = "malloc" , "[" , type_expr , "]" , "(" , expression , ")" ;

addr_expr       = "addr" , "(" , expression , ")" ;
paren_expr      = "(" , expression , ")" ;

arg_list        = expression , { "," , expression } ;

var_expr        = "var" , var_binding , { "," , var_binding } , "in" , expression ;
var_binding     = identifier , [ "=" , expression ] ;

binary_op       = "<"
                | "+" | "-" | "*" | "/"
                | "="
                | custom_op ;

custom_op       = "?" | "$" | "%" | "^" | "&" | "|" | "@" | ":" ;

(* Actual precedence/associativity comes from parser tables, not EBNF. *)
