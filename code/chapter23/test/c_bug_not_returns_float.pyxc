# BUG: `not` operator returns f64 instead of integer.
# `not 0` produces 1.0 (double), so adding it to an i32 goes through
# float arithmetic. This test checks that `not` of an integer
# stays integer so i32 arithmetic works directly.
#
# EXPECTED: If `not` returned i32, result would be 1+1 = 2.
# ACTUAL:   `not 0` returns 1.0 (f64), cast to i32 = 1, then 1+1 = 2.
#           This may still print 2 due to implicit casts, but the type
#           is wrong. A more direct test: store result of `not` into i32
#           and check it's exactly 1 (integer), not 1.0 (float truncated).
#
# The real issue surfaces if you try: printf("%d", not 0)
# because `not 0` is f64 and %d expects integer -> type mismatch error.
#
# RUN: %pyxc -i %s > %t 2>&1
# RUN: grep -x 'not_val=1' %t
# RUN: ! grep -q "Error (Line:" %t

def main() -> i32:
    # This should work: not 0 should give integer 1
    # But not returns f64, so printf %d will reject it
    printf("not_val=%d\n", not 0)
    return 0

main()
