# ast.pyxc - AST node structures for Pyxc self-hosting compiler
# Phase 2: AST structures using tagged unions (no inheritance in pyxc)

# AST Node Type Constants (used in node_type field)
# Expressions:
#   AST_NUMBER      = 1   # Numeric literal
#   AST_STRING      = 2   # String literal
#   AST_VARIABLE    = 3   # Variable reference
#   AST_BINARY      = 4   # Binary operation (a + b)
#   AST_UNARY       = 5   # Unary operation (-a, !a)
#   AST_CALL        = 6   # Function call
#   AST_INDEX       = 7   # Array indexing (a[i])
#   AST_MEMBER      = 8   # Struct member access (a.x)
#   AST_ADDR        = 9   # Address-of (&var)
#   AST_CAST        = 10  # Type cast
#
# Statements:
#   AST_RETURN      = 20  # return statement
#   AST_IF          = 21  # if/else statement
#   AST_WHILE       = 22  # while loop
#   AST_FOR         = 23  # for loop
#   AST_EXPR_STMT   = 24  # Expression statement
#   AST_VAR_DECL    = 25  # Variable declaration
#   AST_ASSIGN      = 26  # Assignment (a = b)
#
# Top-level:
#   AST_PROTOTYPE   = 40  # Function prototype
#   AST_FUNCTION    = 41  # Function definition
#   AST_STRUCT_DEF  = 42  # Struct definition

extern def strcmp(a: ptr[i8], b: ptr[i8]) -> i32
extern def strlen(s: ptr[i8]) -> i64

#===----------------------------------------------------------------------===#
# Expression AST Nodes
#===----------------------------------------------------------------------===#

struct NumberExprAST:
    node_type: i32      # 1 (AST_NUMBER)
    value: f64          # Floating point value
    is_int: i32         # 1 if integer, 0 if float
    int_value: i64      # Integer value

struct StringExprAST:
    node_type: i32      # 2 (AST_STRING)
    value: ptr[i8]      # String content (owned)

struct VariableExprAST:
    node_type: i32      # 3 (AST_VARIABLE)
    name: ptr[i8]       # Variable name (owned)

struct BinaryExprAST:
    node_type: i32      # 4 (AST_BINARY)
    op: i8              # Operator character (+, -, *, /, etc.)
    lhs: ptr[i8]        # Left operand (cast to expr type)
    rhs: ptr[i8]        # Right operand (cast to expr type)

struct UnaryExprAST:
    node_type: i32      # 5 (AST_UNARY)
    op: i8              # Operator character (-, !, ~, etc.)
    operand: ptr[i8]    # Operand expression

struct CallExprAST:
    node_type: i32      # 6 (AST_CALL)
    callee: ptr[i8]     # Function name or expression
    args: ptr[ptr[i8]]  # Array of argument expressions
    num_args: i32       # Number of arguments

struct IndexExprAST:
    node_type: i32      # 7 (AST_INDEX)
    array: ptr[i8]      # Array expression
    index: ptr[i8]      # Index expression

struct MemberExprAST:
    node_type: i32      # 8 (AST_MEMBER)
    object: ptr[i8]     # Object expression
    member: ptr[i8]     # Member name (owned)
    is_arrow: i32       # 1 for ->, 0 for .

struct AddrExprAST:
    node_type: i32      # 9 (AST_ADDR)
    operand: ptr[i8]    # Expression to take address of

struct CastExprAST:
    node_type: i32      # 10 (AST_CAST)
    operand: ptr[i8]    # Expression to cast
    type_name: ptr[i8]  # Target type name (owned)

#===----------------------------------------------------------------------===#
# Statement AST Nodes
#===----------------------------------------------------------------------===#

struct ReturnStmtAST:
    node_type: i32      # 20 (AST_RETURN)
    value: ptr[i8]      # Return value expression (can be 0 for void)

struct IfStmtAST:
    node_type: i32      # 21 (AST_IF)
    cond: ptr[i8]       # Condition expression
    then_body: ptr[ptr[i8]]  # Array of then-branch statements
    then_count: i32     # Number of then statements
    else_body: ptr[ptr[i8]]  # Array of else-branch statements (can be 0)
    else_count: i32     # Number of else statements

struct WhileStmtAST:
    node_type: i32      # 22 (AST_WHILE)
    cond: ptr[i8]       # Condition expression
    body: ptr[ptr[i8]]  # Array of loop body statements
    body_count: i32     # Number of body statements

struct ForStmtAST:
    node_type: i32      # 23 (AST_FOR)
    var_name: ptr[i8]   # Loop variable name (owned)
    start: ptr[i8]      # Start expression
    end: ptr[i8]        # End expression
    step: ptr[i8]       # Step expression (can be 0 for default)
    body: ptr[ptr[i8]]  # Array of loop body statements
    body_count: i32     # Number of body statements

struct ExprStmtAST:
    node_type: i32      # 24 (AST_EXPR_STMT)
    expr: ptr[i8]       # Expression to evaluate

struct VarDeclAST:
    node_type: i32      # 25 (AST_VAR_DECL)
    name: ptr[i8]       # Variable name (owned)
    type_name: ptr[i8]  # Type name (owned)
    init: ptr[i8]       # Initializer expression (can be 0)

struct AssignStmtAST:
    node_type: i32      # 26 (AST_ASSIGN)
    target: ptr[i8]     # Target expression (variable, index, member, etc.)
    value: ptr[i8]      # Value expression

#===----------------------------------------------------------------------===#
# Top-Level AST Nodes
#===----------------------------------------------------------------------===#

struct PrototypeAST:
    node_type: i32           # 40 (AST_PROTOTYPE)
    name: ptr[i8]            # Function name (owned)
    params: ptr[ptr[i8]]     # Array of parameter names (owned)
    param_types: ptr[ptr[i8]]  # Array of parameter type names (owned)
    num_params: i32          # Number of parameters
    return_type: ptr[i8]     # Return type name (owned)
    is_extern: i32           # 1 if extern, 0 if normal

struct FunctionAST:
    node_type: i32           # 41 (AST_FUNCTION)
    proto: ptr[PrototypeAST] # Function prototype (owned)
    body: ptr[ptr[i8]]       # Array of body statements (owned)
    body_count: i32          # Number of body statements

struct StructFieldAST:
    name: ptr[i8]       # Field name (owned)
    type_name: ptr[i8]  # Field type name (owned)

struct StructDefAST:
    node_type: i32           # 42 (AST_STRUCT_DEF)
    name: ptr[i8]            # Struct name (owned)
    fields: ptr[StructFieldAST]  # Array of fields (owned)
    num_fields: i32          # Number of fields

#===----------------------------------------------------------------------===#
# Factory Functions - Expression Nodes
#===----------------------------------------------------------------------===#

def create_number_expr(val: f64, is_int: i32, int_val: i64) -> ptr[NumberExprAST]:
    node: ptr[NumberExprAST] = malloc[NumberExprAST](1)
    node[0].node_type = 1  # AST_NUMBER
    node[0].value = val
    node[0].is_int = is_int
    node[0].int_value = int_val
    return node

def create_string_expr(val: ptr[i8]) -> ptr[StringExprAST]:
    node: ptr[StringExprAST] = malloc[StringExprAST](1)
    node[0].node_type = 2  # AST_STRING

    # Copy string
    len: i64 = strlen(val)
    node[0].value = malloc[i8](len + 1)
    dst: ptr[i8] = node[0].value
    i: i64 = 0
    while i < len:
        dst[i] = val[i]
        i = i + 1
    dst[len] = 0

    return node

def create_variable_expr(name: ptr[i8]) -> ptr[VariableExprAST]:
    node: ptr[VariableExprAST] = malloc[VariableExprAST](1)
    node[0].node_type = 3  # AST_VARIABLE

    # Copy name
    len: i64 = strlen(name)
    node[0].name = malloc[i8](len + 1)
    dst: ptr[i8] = node[0].name
    i: i64 = 0
    while i < len:
        dst[i] = name[i]
        i = i + 1
    dst[len] = 0

    return node

def create_binary_expr(op: i8, lhs: ptr[i8], rhs: ptr[i8]) -> ptr[BinaryExprAST]:
    node: ptr[BinaryExprAST] = malloc[BinaryExprAST](1)
    node[0].node_type = 4  # AST_BINARY
    node[0].op = op
    node[0].lhs = lhs
    node[0].rhs = rhs
    return node

def create_unary_expr(op: i8, operand: ptr[i8]) -> ptr[UnaryExprAST]:
    node: ptr[UnaryExprAST] = malloc[UnaryExprAST](1)
    node[0].node_type = 5  # AST_UNARY
    node[0].op = op
    node[0].operand = operand
    return node

def create_call_expr(callee: ptr[i8], args: ptr[ptr[i8]], num_args: i32) -> ptr[CallExprAST]:
    node: ptr[CallExprAST] = malloc[CallExprAST](1)
    node[0].node_type = 6  # AST_CALL
    node[0].callee = callee
    node[0].args = args
    node[0].num_args = num_args
    return node

def create_index_expr(array: ptr[i8], index: ptr[i8]) -> ptr[IndexExprAST]:
    node: ptr[IndexExprAST] = malloc[IndexExprAST](1)
    node[0].node_type = 7  # AST_INDEX
    node[0].array = array
    node[0].index = index
    return node

def create_member_expr(object: ptr[i8], member: ptr[i8], is_arrow: i32) -> ptr[MemberExprAST]:
    node: ptr[MemberExprAST] = malloc[MemberExprAST](1)
    node[0].node_type = 8  # AST_MEMBER
    node[0].object = object

    # Copy member name
    len: i64 = strlen(member)
    node[0].member = malloc[i8](len + 1)
    dst: ptr[i8] = node[0].member
    i: i64 = 0
    while i < len:
        dst[i] = member[i]
        i = i + 1
    dst[len] = 0

    node[0].is_arrow = is_arrow
    return node

def create_addr_expr(operand: ptr[i8]) -> ptr[AddrExprAST]:
    node: ptr[AddrExprAST] = malloc[AddrExprAST](1)
    node[0].node_type = 9  # AST_ADDR
    node[0].operand = operand
    return node

def create_cast_expr(operand: ptr[i8], type_name: ptr[i8]) -> ptr[CastExprAST]:
    node: ptr[CastExprAST] = malloc[CastExprAST](1)
    node[0].node_type = 10  # AST_CAST
    node[0].operand = operand

    # Copy type name
    len: i64 = strlen(type_name)
    node[0].type_name = malloc[i8](len + 1)
    dst: ptr[i8] = node[0].type_name
    i: i64 = 0
    while i < len:
        dst[i] = type_name[i]
        i = i + 1
    dst[len] = 0

    return node

#===----------------------------------------------------------------------===#
# Factory Functions - Statement Nodes
#===----------------------------------------------------------------------===#

def create_return_stmt(value: ptr[i8]) -> ptr[ReturnStmtAST]:
    node: ptr[ReturnStmtAST] = malloc[ReturnStmtAST](1)
    node[0].node_type = 20  # AST_RETURN
    node[0].value = value
    return node

def create_if_stmt(cond: ptr[i8], then_body: ptr[ptr[i8]], then_count: i32, else_body: ptr[ptr[i8]], else_count: i32) -> ptr[IfStmtAST]:
    node: ptr[IfStmtAST] = malloc[IfStmtAST](1)
    node[0].node_type = 21  # AST_IF
    node[0].cond = cond
    node[0].then_body = then_body
    node[0].then_count = then_count
    node[0].else_body = else_body
    node[0].else_count = else_count
    return node

def create_while_stmt(cond: ptr[i8], body: ptr[ptr[i8]], body_count: i32) -> ptr[WhileStmtAST]:
    node: ptr[WhileStmtAST] = malloc[WhileStmtAST](1)
    node[0].node_type = 22  # AST_WHILE
    node[0].cond = cond
    node[0].body = body
    node[0].body_count = body_count
    return node

def create_for_stmt(var_name: ptr[i8], start: ptr[i8], end: ptr[i8], step: ptr[i8], body: ptr[ptr[i8]], body_count: i32) -> ptr[ForStmtAST]:
    node: ptr[ForStmtAST] = malloc[ForStmtAST](1)
    node[0].node_type = 23  # AST_FOR

    # Copy variable name
    len: i64 = strlen(var_name)
    node[0].var_name = malloc[i8](len + 1)
    dst: ptr[i8] = node[0].var_name
    i: i64 = 0
    while i < len:
        dst[i] = var_name[i]
        i = i + 1
    dst[len] = 0

    node[0].start = start
    node[0].end = end
    node[0].step = step
    node[0].body = body
    node[0].body_count = body_count
    return node

def create_expr_stmt(expr: ptr[i8]) -> ptr[ExprStmtAST]:
    node: ptr[ExprStmtAST] = malloc[ExprStmtAST](1)
    node[0].node_type = 24  # AST_EXPR_STMT
    node[0].expr = expr
    return node

def create_var_decl(name: ptr[i8], type_name: ptr[i8], init: ptr[i8]) -> ptr[VarDeclAST]:
    node: ptr[VarDeclAST] = malloc[VarDeclAST](1)
    node[0].node_type = 25  # AST_VAR_DECL

    # Copy variable name
    len: i64 = strlen(name)
    node[0].name = malloc[i8](len + 1)
    name_dst: ptr[i8] = node[0].name
    i: i64 = 0
    while i < len:
        name_dst[i] = name[i]
        i = i + 1
    name_dst[len] = 0

    # Copy type name
    len = strlen(type_name)
    node[0].type_name = malloc[i8](len + 1)
    type_dst: ptr[i8] = node[0].type_name
    i = 0
    while i < len:
        type_dst[i] = type_name[i]
        i = i + 1
    type_dst[len] = 0

    node[0].init = init
    return node

def create_assign_stmt(target: ptr[i8], value: ptr[i8]) -> ptr[AssignStmtAST]:
    node: ptr[AssignStmtAST] = malloc[AssignStmtAST](1)
    node[0].node_type = 26  # AST_ASSIGN
    node[0].target = target
    node[0].value = value
    return node

#===----------------------------------------------------------------------===#
# Factory Functions - Top-Level Nodes
#===----------------------------------------------------------------------===#

def create_prototype(name: ptr[i8], params: ptr[ptr[i8]], param_types: ptr[ptr[i8]], num_params: i32, return_type: ptr[i8], is_extern: i32) -> ptr[PrototypeAST]:
    node: ptr[PrototypeAST] = malloc[PrototypeAST](1)
    node[0].node_type = 40  # AST_PROTOTYPE

    # Copy function name
    len: i64 = strlen(name)
    node[0].name = malloc[i8](len + 1)
    name_dst: ptr[i8] = node[0].name
    i: i64 = 0
    while i < len:
        name_dst[i] = name[i]
        i = i + 1
    name_dst[len] = 0

    node[0].params = params
    node[0].param_types = param_types
    node[0].num_params = num_params

    # Copy return type
    len = strlen(return_type)
    node[0].return_type = malloc[i8](len + 1)
    ret_dst: ptr[i8] = node[0].return_type
    i = 0
    while i < len:
        ret_dst[i] = return_type[i]
        i = i + 1
    ret_dst[len] = 0

    node[0].is_extern = is_extern
    return node

def create_function(proto: ptr[PrototypeAST], body: ptr[ptr[i8]], body_count: i32) -> ptr[FunctionAST]:
    node: ptr[FunctionAST] = malloc[FunctionAST](1)
    node[0].node_type = 41  # AST_FUNCTION
    node[0].proto = proto
    node[0].body = body
    node[0].body_count = body_count
    return node

def create_struct_def(name: ptr[i8], fields: ptr[StructFieldAST], num_fields: i32) -> ptr[StructDefAST]:
    node: ptr[StructDefAST] = malloc[StructDefAST](1)
    node[0].node_type = 42  # AST_STRUCT_DEF

    # Copy struct name
    len: i64 = strlen(name)
    node[0].name = malloc[i8](len + 1)
    dst: ptr[i8] = node[0].name
    i: i64 = 0
    while i < len:
        dst[i] = name[i]
        i = i + 1
    dst[len] = 0

    node[0].fields = fields
    node[0].num_fields = num_fields
    return node

#===----------------------------------------------------------------------===#
# Memory Management - Free Functions
#===----------------------------------------------------------------------===#

def free_expr(expr: ptr[i8]) -> void:
    if not expr:
        return

    # Get node type from first field
    type_ptr: ptr[i32] = expr
    node_type: i32 = type_ptr[0]

    if node_type == 1:
        free(expr)
    elif node_type == 2:
        node: ptr[StringExprAST] = expr
        free(node[0].value)
        free(expr)
    elif node_type == 3:
        node: ptr[VariableExprAST] = expr
        free(node[0].name)
        free(expr)
    elif node_type == 4:
        node: ptr[BinaryExprAST] = expr
        free_expr(node[0].lhs)
        free_expr(node[0].rhs)
        free(expr)
    elif node_type == 5:
        node: ptr[UnaryExprAST] = expr
        free_expr(node[0].operand)
        free(expr)
    elif node_type == 6:
        node: ptr[CallExprAST] = expr
        free_expr(node[0].callee)
        args: ptr[ptr[i8]] = node[0].args
        i: i32 = 0
        while i < node[0].num_args:
            free_expr(args[i])
            i = i + 1
        free(args)
        free(expr)
    elif node_type == 7:
        node: ptr[IndexExprAST] = expr
        free_expr(node[0].array)
        free_expr(node[0].index)
        free(expr)
    elif node_type == 8:
        node: ptr[MemberExprAST] = expr
        free_expr(node[0].object)
        free(node[0].member)
        free(expr)
    elif node_type == 9:
        node: ptr[AddrExprAST] = expr
        free_expr(node[0].operand)
        free(expr)
    elif node_type == 10:
        node: ptr[CastExprAST] = expr
        free_expr(node[0].operand)
        free(node[0].type_name)
        free(expr)
    else:
        free(expr)

def free_stmt(stmt: ptr[i8]) -> void:
    if not stmt:
        return

    # Get node type from first field
    type_ptr: ptr[i32] = stmt
    node_type: i32 = type_ptr[0]

    if node_type == 20:
        node: ptr[ReturnStmtAST] = stmt
        free_expr(node[0].value)
        free(stmt)
    elif node_type == 21:
        node: ptr[IfStmtAST] = stmt
        free_expr(node[0].cond)
        then_body: ptr[ptr[i8]] = node[0].then_body
        i: i32 = 0
        while i < node[0].then_count:
            free_stmt(then_body[i])
            i = i + 1
        free(then_body)
        else_body: ptr[ptr[i8]] = node[0].else_body
        i = 0
        while i < node[0].else_count:
            free_stmt(else_body[i])
            i = i + 1
        if else_body:
            free(else_body)
        free(stmt)
    elif node_type == 22:
        node: ptr[WhileStmtAST] = stmt
        free_expr(node[0].cond)
        body: ptr[ptr[i8]] = node[0].body
        i: i32 = 0
        while i < node[0].body_count:
            free_stmt(body[i])
            i = i + 1
        free(body)
        free(stmt)
    elif node_type == 23:
        node: ptr[ForStmtAST] = stmt
        free(node[0].var_name)
        free_expr(node[0].start)
        free_expr(node[0].end)
        free_expr(node[0].step)
        body: ptr[ptr[i8]] = node[0].body
        i: i32 = 0
        while i < node[0].body_count:
            free_stmt(body[i])
            i = i + 1
        free(body)
        free(stmt)
    elif node_type == 24:
        node: ptr[ExprStmtAST] = stmt
        free_expr(node[0].expr)
        free(stmt)
    elif node_type == 25:
        node: ptr[VarDeclAST] = stmt
        free(node[0].name)
        free(node[0].type_name)
        free_expr(node[0].init)
        free(stmt)
    elif node_type == 26:
        node: ptr[AssignStmtAST] = stmt
        free_expr(node[0].target)
        free_expr(node[0].value)
        free(stmt)
    else:
        free(stmt)

def free_prototype(proto: ptr[PrototypeAST]) -> void:
    if not proto:
        return

    free(proto[0].name)

    # Free parameter names
    i: i32 = 0
    params: ptr[ptr[i8]] = proto[0].params
    param_types: ptr[ptr[i8]] = proto[0].param_types
    while i < proto[0].num_params:
        free(params[i])
        free(param_types[i])
        i = i + 1

    if params:
        free(params)
    if param_types:
        free(param_types)

    free(proto[0].return_type)
    free(proto)

def free_function(func: ptr[FunctionAST]) -> void:
    if not func:
        return

    free_prototype(func[0].proto)

    # Free body statements
    body: ptr[ptr[i8]] = func[0].body
    i: i32 = 0
    while i < func[0].body_count:
        free_stmt(body[i])
        i = i + 1

    if body:
        free(body)

    free(func)

def free_struct_def(sdef: ptr[StructDefAST]) -> void:
    if not sdef:
        return

    free(sdef[0].name)

    # Free fields
    fields: ptr[StructFieldAST] = sdef[0].fields
    i: i32 = 0
    while i < sdef[0].num_fields:
        free(fields[i].name)
        free(fields[i].type_name)
        i = i + 1

    if fields:
        free(fields)

    free(sdef)
